<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¿Qué aprendimos? Práctica de Prompts</title>
    
    <!-- Dependencias de fuentes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Google Analytics -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F5DXVF2JX3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-F5DXVF2JX3');
    </script>
    
    <!-- Estilos externos -->
    <link rel="stylesheet" href="css/styles.css">
    
    <!-- Scripts SCORM -->
    <script src="js/config.js"></script>
    <script src="js/scorm_api.js"></script>
</head>
<body>

    <!-- Estructura HTML del widget -->
    <div class="prompt-creation-widget">
        <header class="pcw-header">
            <h1>
                <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83zM3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"/></svg>
                ¿Qué aprendimos? Práctica de Prompts
            </h1>
            <p>Redacte un prompt para cumplir el objetivo y reciba una evaluación automática.</p>
        </header>

        <!-- Indicador de progreso SCORM -->
        <div class="pcw-progress-bar">
            <div class="pcw-progress-fill" id="progressFill"></div>
            <span class="pcw-progress-text" id="progressText">Progreso: 0%</span>
        </div>

        <!-- Indicadores de estado de conexión -->
        <div class="pcw-status-indicators">
            <div class="pcw-status-indicator" id="aiStatus">
                <svg class="pcw-status-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
                <span class="pcw-status-text">IA</span>
                <div class="pcw-status-dot pcw-status-disconnected"></div>
            </div>
            
            <div class="pcw-status-indicator" id="scormStatus">
                <svg class="pcw-status-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M20 18c1.1 0 1.99-.9 1.99-2L22 6c0-1.1-.9-2-2-2H4c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2H0v2h24v-2h-4zM4 6h16v10H4V6z"/>
                </svg>
                <span class="pcw-status-text">LMS</span>
                <div class="pcw-status-dot pcw-status-disconnected"></div>
            </div>
        </div>

        <main class="pcw-main-content">
            <div class="pcw-panel pcw-panel-creation">
                <h2 class="pcw-section-title">
                    <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>
                    Panel de creación
                </h2>
                <div class="pcw-form-group">
                    <label for="scenarioSelector">1. Seleccione un escenario:</label>
                    <select id="scenarioSelector" class="pcw-select"></select>
                    <div class="pcw-scenario-description" id="scenarioDescription"></div>
                </div>
                <div class="pcw-form-group">
                    <label for="studentPrompt">2. Escriba su prompt aquí:</label>
                    <textarea id="studentPrompt" class="pcw-textarea" placeholder="Redacte su instrucción para lograr el objetivo descrito..."></textarea>
                </div>
                <button id="showRubricButton" class="pcw-button pcw-button-secondary">
                     <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></svg>
                    Ver pauta de evaluación
                </button>
                <button id="analyzeButton" class="pcw-button">
                    <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                    Analizar mi prompt
                </button>
                
                <!-- Botón para finalizar actividad -->
                <button id="completeActivityButton" class="pcw-button pcw-button-complete" style="display:none;">
                    <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
                    Finalizar actividad
                </button>
            </div>
            
            <div class="pcw-panel pcw-feedback-panel">
                 <h2 class="pcw-section-title">
                    <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27z"/></svg>
                    Análisis del revisor
                </h2>
                <div id="feedbackContainer">
                    <div class="pcw-feedback-placeholder">
                        <p>Aquí aparecerá la retroalimentación detallada sobre su prompt.</p>
                    </div>
                </div>
            </div>
        </main>
        
        <footer class="pcw-footer">
            Desarrollo digital: Google Gemini 2.5 Pro y Claude Sonnet 4. La IA generó el código base (HTML, CSS, JavaScript), sintetizó el contenido y actúa como el motor de evaluación en tiempo real, bajo la dirección y refinamiento del autor.<br>
            Contenido académico: Francisco Sereño | Damaris Reinoso (practicante)<br>
            Versión: 1.0 - Julio 2025 | Paquete SCORM 2004<br>
            Tecnologías: HTML5, CSS3, JavaScript, OpenAI API, SCORM 2004, Google Analytics<br>
            <small>Esta aplicación utiliza Google Analytics para métricas educativas anónimas</small>
        </footer>
        
        <!-- Modal para la pauta -->
        <div id="rubricModal" class="pcw-modal">
            <div class="pcw-modal-content">
                <span class="pcw-modal-close">&times;</span>
                <h3 id="rubricModalTitle">Pauta de evaluación</h3>
                <div id="rubricModalBody"></div>
            </div>
        </div>
        
        <!-- Modal de confirmación SCORM -->
        <div id="scormModal" class="pcw-modal">
            <div class="pcw-modal-content">
                <h3>Actividad finalizada</h3>
                <p id="scormModalMessage">Su calificación ha sido registrada exitosamente en el sistema.</p>
                <button id="scormModalClose" class="pcw-button">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- Script principal de la aplicación -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Variables SCORM globales
        let scormInitialized = false;
        let currentScore = 0;
        let totalAttempts = 0;
        let isActivityCompleted = false;
        let aiConnected = false;
        let scormConnected = false;

        const widget = document.querySelector('.prompt-creation-widget');

        if (!widget) {
            console.error("Error crítico: No se pudo encontrar el contenedor del widget .prompt-creation-widget.");
            return; 
        }

        if (widget.hasAttribute('data-initialized')) {
            return; 
        }
        widget.setAttribute('data-initialized', 'true');
        
        // Inicializar SCORM
        initializeScorm();
        
        // Referencias a elementos DOM
        const scenarioSelector = widget.querySelector('#scenarioSelector');
        const scenarioDescription = widget.querySelector('#scenarioDescription');
        const studentPromptEl = widget.querySelector('#studentPrompt');
        const analyzeButton = widget.querySelector('#analyzeButton');
        const feedbackContainer = widget.querySelector('#feedbackContainer');
        const showRubricButton = widget.querySelector('#showRubricButton');
        const completeActivityButton = widget.querySelector('#completeActivityButton');
        const progressFill = widget.querySelector('#progressFill');
        const progressText = widget.querySelector('#progressText');
        
        // Referencias a modales
        const rubricModal = widget.querySelector('#rubricModal');
        const rubricModalTitle = widget.querySelector('#rubricModalTitle');
        const rubricModalBody = widget.querySelector('#rubricModalBody');
        const closeModalButton = widget.querySelector('.pcw-modal-close');
        const scormModal = widget.querySelector('#scormModal');
        const scormModalMessage = widget.querySelector('#scormModalMessage');
        const scormModalClose = widget.querySelector('#scormModalClose');

        // Configuración de escenarios (misma que el original)
        const scenarios = {
            'recipe': {
                name: 'Crear una receta con ingredientes disponibles',
                goal: 'Su objetivo es que la IA genere una receta para la cena usando solo los ingredientes que tiene en su refrigerador: pollo, arroz, tomates y cebolla. La receta debe ser rápida (menos de 45 minutos) y saludable.',
                technique: 'Dar contexto (Contextual Prompting)',
                rubric: [
                    { criterion: 'Lista explícita de ingredientes', score: 10 },
                    { criterion: 'Definición de restricciones de tiempo', score: 10 },
                    { criterion: 'Definición de restricciones de dieta', score: 10 },
                    { criterion: 'Solicitud de un formato de salida claro', score: 10 }
                ]
            },
            'email': {
                name: 'Redactar un correo difícil',
                goal: 'Su objetivo es que la IA le ayude a redactar un correo formal pero firme a su arrendador para solicitar una reparación urgente de una filtración en el baño que no ha sido atendida.',
                technique: 'Asignar un rol (Role Prompting)',
                rubric: [
                    { criterion: 'Asignación de un tono o rol', score: 10 },
                    { criterion: 'Inclusión del contexto del problema', score: 10 },
                    { criterion: 'Establecimiento de un objetivo claro', score: 10 },
                    { criterion: 'Petición de una acción o plazo', score: 10 }
                ]
            },
            'planning': {
                name: 'Creación de un plan de estudio',
                goal: 'Su objetivo es que la IA elabore un plan de estudio personalizado para aprender a tocar guitarra desde cero. Debe considerar que usted dispone de 4 horas a la semana y su meta es poder tocar una canción simple en 3 meses.',
                technique: 'Dar contexto (Contextual Prompting)',
                rubric: [
                    { criterion: 'Contexto temporal y de dedicación', score: 10 },
                    { criterion: 'Meta de aprendizaje clara y medible', score: 10 },
                    { criterion: 'Nivel de habilidad inicial', score: 10 },
                    { criterion: 'Solicitud de una estructura de plan', score: 10 }
                ]
            },
            'weekend': {
                name: 'Planificar una actividad de fin de semana',
                goal: 'Su objetivo es que la IA le ayude a decidir qué hacer el fin de semana. Una persona quiere ir a la playa y la otra prefiere la montaña. Pida a la IA que proponga 3 soluciones que satisfagan a ambos, evaluando para cada una el costo, el tiempo de viaje y el nivel de actividad física.',
                technique: 'Explorar varias opciones (Tree of Thoughts)',
                rubric: [
                    { criterion: 'Planteamiento claro del conflicto o dilema', score: 10 },
                    { criterion: 'Solicitud de un número específico de alternativas', score: 10 },
                    { criterion: 'Definición de criterios de evaluación claros', score: 10 },
                    { criterion: 'Consideración de preferencias de ambos', score: 10 }
                ]
            },
            'gift-ideas': {
                name: 'Brainstorming de regalos',
                goal: 'Necesita ideas de regalo para el cumpleaños de su padre. Le gusta la jardinería, la historia y la cocina. Su presupuesto es de 50 USD.',
                technique: 'Dar contexto (Contextual Prompting)',
                rubric: [
                    { criterion: 'Contexto de intereses de la persona', score: 10 },
                    { criterion: 'Definición de presupuesto', score: 10 },
                    { criterion: 'Solicitud de un número de ideas', score: 10 },
                    { criterion: 'Especificación del tipo de regalo', score: 10 }
                ]
            },
            'explain-topic': {
                name: 'Explicar un tema a un amigo',
                goal: 'Quiere que la IA le ayude a explicarle a un amigo, que no sabe nada de finanzas, qué es la inflación y cómo afecta su poder de compra, usando un ejemplo simple.',
                technique: 'Ser más específico (Zero-shot)',
                rubric: [
                    { criterion: 'Definición del público objetivo', score: 10 },
                    { criterion: 'Tema específico a explicar', score: 10 },
                    { criterion: 'Solicitud de analogía o ejemplo', score: 10 },
                    { criterion: 'Definición del formato de la explicación', score: 10 }
                ]
            }
        };
        
        // Funciones de Google Analytics para tracking educativo
        function trackEvent(eventName, parameters = {}) {
            if (typeof gtag !== 'undefined') {
                gtag('event', eventName, {
                    custom_parameter: 'scorm_prompts_activity',
                    ...parameters
                });
                console.log(`📊 Analytics: ${eventName}`, parameters);
            }
        }

        function trackScenarioSelection(scenarioKey, scenarioName) {
            trackEvent('scenario_selected', {
                scenario_id: scenarioKey,
                scenario_name: scenarioName,
                event_category: 'learning_interaction'
            });
        }

        function trackPromptSubmission(scenarioKey, score, totalAttempts) {
            trackEvent('prompt_submitted', {
                scenario_id: scenarioKey,
                score: score,
                max_score: 40,
                percentage: Math.round((score / 40) * 100),
                attempt_number: totalAttempts,
                event_category: 'assessment'
            });
        }

        function trackActivityCompletion(finalScore, totalAttempts) {
            trackEvent('activity_completed', {
                final_score: finalScore,
                max_score: 40,
                percentage: Math.round((finalScore / 40) * 100),
                total_attempts: totalAttempts,
                grade: calculateGrade(finalScore, 40),
                event_category: 'achievement'
            });
        }

        function trackSessionStart() {
            trackEvent('session_started', {
                timestamp: new Date().toISOString(),
                event_category: 'engagement'
            });
        }
        function initializeScorm() {
            try {
                scormInitialized = initializeSCORM();
                if (scormInitialized) {
                    // Cargar datos previos si existen
                    loadPreviousData();
                    updateProgress(10); // Progreso inicial por cargar la actividad
                    console.log("SCORM inicializado correctamente");
                    
                    // Debug inicial
                    debugScormState();
                } else {
                    console.warn("No se pudo inicializar SCORM - modo de desarrollo");
                }
            } catch (error) {
                console.error("Error al inicializar SCORM:", error);
            }
        }

        function debugScormState() {
            if (!scormInitialized) return;
            
            console.log("=== ESTADO SCORM ACTUAL ===");
            console.log("Initialized:", scormInitialized);
            console.log("Lesson Status:", getSCORMData('cmi.core.lesson_status'));
            console.log("Score Raw:", getSCORMData('cmi.core.score.raw'));
            console.log("Score Max:", getSCORMData('cmi.core.score.max'));
            console.log("Score Min:", getSCORMData('cmi.core.score.min'));
            console.log("Lesson Location:", getSCORMData('cmi.core.lesson_location'));
            console.log("Suspend Data:", getSCORMData('cmi.suspend_data'));
            console.log("Session Time:", getSCORMData('cmi.core.session_time'));
            console.log("Total Time:", getSCORMData('cmi.core.total_time'));
            console.log("Entry:", getSCORMData('cmi.core.entry'));
            console.log("Exit:", getSCORMData('cmi.core.exit'));
            console.log("Mode:", getSCORMData('cmi.core.mode'));
            console.log("Credit:", getSCORMData('cmi.core.credit'));
            console.log("==========================");
        }

        function loadPreviousData() {
            if (!scormInitialized) return;
            
            try {
                const savedLocation = getSCORMData('cmi.core.lesson_location');
                const savedScoreRaw = getSCORMData('cmi.core.score.raw');
                const savedSuspendData = getSCORMData('cmi.suspend_data');
                const savedLessonStatus = getSCORMData('cmi.core.lesson_status');
                
                console.log("=== CARGANDO ESTADO PREVIO ===");
                console.log("Location:", savedLocation);
                console.log("Score Raw:", savedScoreRaw);
                console.log("Lesson Status:", savedLessonStatus);
                console.log("Suspend Data:", savedSuspendData);
                
                // VERIFICAR SI LA ACTIVIDAD YA ESTÁ COMPLETADA
                let isCompleted = false;
                let completionData = null;
                
                if (savedLocation && savedLocation.startsWith('COMPLETED_')) {
                    isCompleted = true;
                    console.log("🔒 ACTIVIDAD YA COMPLETADA - BLOQUEANDO INTERFAZ");
                }
                
                if (savedSuspendData) {
                    try {
                        completionData = JSON.parse(savedSuspendData);
                        if (completionData.isCompleted) {
                            isCompleted = true;
                        }
                    } catch (e) {
                        console.error("Error al parsear suspend_data:", e);
                    }
                }
                
                // Si está completada, mostrar pantalla de bloqueo
                if (isCompleted && completionData) {
                    showCompletionScreen(completionData);
                    return;
                }
                
                // Si hay datos pero no está completada, restaurar estado
                if (savedSuspendData && !isCompleted) {
                    try {
                        const suspendData = JSON.parse(savedSuspendData);
                        
                        currentScore = suspendData.rawScore || 0;
                        totalAttempts = suspendData.attempts || 0;
                        
                        if (suspendData.scenarioKey && scenarios[suspendData.scenarioKey]) {
                            scenarioSelector.value = suspendData.scenarioKey;
                            updateDescription();
                        }
                        
                        if (suspendData.percentage) {
                            updateProgress(suspendData.percentage);
                        }
                        
                        if (suspendData.lastEvaluation) {
                            renderFeedback(suspendData.lastEvaluation);
                            
                            if (suspendData.percentage >= 60) {
                                completeActivityButton.style.display = 'block';
                            }
                        }
                        
                        console.log("✅ Estado en progreso restaurado:", suspendData);
                        
                    } catch (e) {
                        console.error("❌ Error al restaurar estado:", e);
                    }
                }
                
                // Actualizar contador de intentos
                updateAttemptsDisplay();
                
            } catch (error) {
                console.error("❌ Error crítico al cargar datos previos:", error);
            }
        }

        function showCompletionScreen(completionData) {
            // Bloquear toda la interfaz
            const mainContent = widget.querySelector('.pcw-main-content');
            const header = widget.querySelector('.pcw-header');
            
            // Actualizar el header con estado de finalización
            header.innerHTML = `
                <h1>
                    <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Actividad Completada
                </h1>
                <p>Esta actividad ya ha sido finalizada y calificada.</p>
            `;
            
            // Crear pantalla de resumen final
            const statusIcon = completionData.isPassed ? 
                `<svg style="width: 64px; height: 64px; color: #1e8449;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>` :
                `<svg style="width: 64px; height: 64px; color: #d68910;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
                </svg>`;
            
            const statusMessage = completionData.isPassed ? 
                "¡Felicitaciones! Ha aprobado la actividad." : 
                "La actividad ha sido completada pero no aprobada.";
            
            const statusClass = completionData.isPassed ? 'passed' : 'failed';
            
            mainContent.innerHTML = `
                <div style="text-align: center; padding: 60px 40px; background: white; border-radius: 16px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);">
                    ${statusIcon}
                    
                    <h2 style="margin: 30px 0 20px; font-size: 2rem; color: ${completionData.isPassed ? '#1e8449' : '#d68910'};">
                        ${completionData.isPassed ? 'APROBADO' : 'REPROBADO'}
                    </h2>
                    
                    <p style="font-size: 1.2rem; color: #333; margin-bottom: 30px;">
                        ${statusMessage}
                    </p>
                    
                    <div style="background: #f8f9fa; border-radius: 12px; padding: 30px; margin: 30px 0; border-left: 6px solid ${completionData.isPassed ? '#1e8449' : '#d68910'};">
                        <h3 style="margin: 0 0 20px; color: #333;">Resumen de Calificación</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; text-align: left; max-width: 400px; margin: 0 auto;">
                            <div><strong>Puntaje obtenido:</strong></div>
                            <div>${completionData.rawScore}/${completionData.maxScore} puntos</div>
                            
                            <div><strong>Porcentaje:</strong></div>
                            <div>${completionData.percentage}%</div>
                            
                            <div><strong>Nota:</strong></div>
                            <div>${completionData.grade}</div>
                            
                            <div><strong>Intentos utilizados:</strong></div>
                            <div>${completionData.attempts}/3</div>
                            
                            <div><strong>Estado:</strong></div>
                            <div style="color: ${completionData.isPassed ? '#1e8449' : '#d68910'}; font-weight: bold;">
                                ${completionData.isPassed ? 'APROBADO' : 'REPROBADO'}
                            </div>
                            
                            <div><strong>Fecha:</strong></div>
                            <div>${new Date(completionData.completionTime).toLocaleString('es-CL')}</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 40px; padding: 20px; background: #e3f2fd; border-radius: 8px; color: #1565c0;">
                        <p style="margin: 0; font-size: 0.95rem;">
                            <strong>Información:</strong> Esta actividad ha sido registrada en su calificación. 
                            La nota final aparecerá en el libro de calificaciones de la plataforma.
                        </p>
                    </div>
                    
                    <div style="margin-top: 30px; font-size: 0.9rem; color: #6c757d;">
                        🔒 La actividad está bloqueada para preservar la calificación registrada.
                    </div>
                </div>
            `;
            
            // Actualizar barra de progreso
            if (progressFill && progressText) {
                progressFill.style.width = '100%';
                progressText.textContent = `Completado: ${completionData.percentage}% | Intentos: ${completionData.attempts}/3`;
            }
            
            // Marcar como completado
            isActivityCompleted = true;
            currentScore = completionData.rawScore;
            totalAttempts = completionData.attempts;
            
            console.log("🔒 PANTALLA DE FINALIZACIÓN MOSTRADA");
            console.log(`Puntaje final: ${completionData.rawScore}/${completionData.maxScore}`);
            console.log(`Estado: ${completionData.isPassed ? 'APROBADO' : 'REPROBADO'}`);
        }

        function updateAttemptsDisplay() {
            const remainingAttempts = SCORM_CONFIG.maxAttempts - totalAttempts;
            
            // Actualizar texto del botón según los intentos restantes
            if (remainingAttempts <= 0) {
                analyzeButton.textContent = getLocalizedText('attemptLimitReached');
                analyzeButton.disabled = true;
            } else {
                analyzeButton.innerHTML = `
                    <svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
                    Analizar mi prompt (${remainingAttempts}/3 ${getLocalizedText('attemptsRemaining')})
                `;
            }
            
            // Actualizar información en el progreso
            if (progressText) {
                const baseText = progressText.textContent.split('|')[0];
                progressText.textContent = `${baseText} | Intentos: ${totalAttempts}/${SCORM_CONFIG.maxAttempts}`;
            }
            
            console.log(`Intentos actualizados: ${totalAttempts}/${SCORM_CONFIG.maxAttempts} (quedan ${remainingAttempts})`);
        }

        function updateProgress(percentage) {
            if (progressFill && progressText) {
                progressFill.style.width = percentage + '%';
                
                // Actualizar texto con información de intentos
                const attemptInfo = ` | Intentos: ${totalAttempts}/${SCORM_CONFIG.maxAttempts}`;
                progressText.textContent = `Progreso: ${Math.round(percentage)}%${attemptInfo}`;
                
                // Actualizar progreso en SCORM
                if (scormInitialized) {
                    setSCORMData('cmi.core.lesson_location', `attempt_${totalAttempts}_progress_${Math.round(percentage)}`);
                }
            }
        }

        function registerScoreInLMS(score, maxScore) {
            if (!scormInitialized) {
                console.log("Modo desarrollo - Calificación:", score, "/", maxScore);
                return;
            }

            try {
                // Calcular porcentaje exacto
                const percentage = Math.round((score / maxScore) * 100);
                const grade = calculateGrade(score, maxScore);
                
                // SCORM espera valores de 0-100 para el porcentaje
                // Usar el porcentaje como score.raw en escala 0-100
                setSCORMData('cmi.core.score.raw', percentage.toString());
                setSCORMData('cmi.core.score.max', '100');
                setSCORMData('cmi.core.score.min', '0');
                
                // También guardar el puntaje original en suspend_data para referencia
                const suspendData = {
                    rawScore: score,
                    maxScore: maxScore,
                    percentage: percentage,
                    grade: grade,
                    timestamp: new Date().toISOString()
                };
                setSCORMData('cmi.suspend_data', JSON.stringify(suspendData));
                
                // Registrar estado basado en puntaje de aprobación (60% = nota 4.0)
                if (percentage >= 60) {
                    setSCORMData('cmi.core.lesson_status', 'passed');
                } else {
                    setSCORMData('cmi.core.lesson_status', 'failed');
                }
                
                // Actualizar progreso visual
                updateProgress(percentage);
                
                // Mostrar botón de completar si alcanza el puntaje mínimo de aprobación
                if (percentage >= 60 && !isActivityCompleted) {
                    setSCORMData('cmi.core.session_time', calculateSessionTime());
                    isActivityCompleted = true;
                    completeActivityButton.style.display = 'block';
                }
                
                currentScore = score;
                commitSCORMData();
                
                console.log(`Calificación registrada en LMS: ${score}/${maxScore} = ${percentage}% (Nota: ${grade})`);
                console.log(`Datos SCORM enviados: raw=${percentage}, max=100, status=${percentage >= 70 ? 'passed' : 'failed'}`);
                
            } catch (error) {
                console.error("Error al registrar calificación en LMS:", error);
            }
        }

        function calculateSessionTime() {
            // Implementación básica - en un caso real podrías rastrear el tiempo real
            return "PT45M"; // 45 minutos en formato ISO 8601
        }

        function completeActivity() {
            if (!scormInitialized) {
                alert("Actividad completada en modo desarrollo");
                return;
            }

            try {
                const percentage = Math.round((currentScore / 40) * 100);
                const grade = calculateGrade(currentScore, 40);
                const isPassed = percentage >= 60;
                
                console.log("=== FINALIZANDO ACTIVIDAD ===");
                console.log(`Puntaje final: ${currentScore}/40`);
                console.log(`Porcentaje: ${percentage}%`);
                console.log(`Estado: ${isPassed ? 'APROBADO' : 'REPROBADO'}`);
                
                // Datos de finalización completos
                const completionData = {
                    rawScore: currentScore,
                    maxScore: 40,
                    percentage: percentage,
                    grade: grade,
                    isPassed: isPassed,
                    isCompleted: true,
                    attempts: totalAttempts,
                    scenarioKey: scenarioSelector.value,
                    completionTime: new Date().toISOString(),
                    lastEvaluation: null
                };
                
                // Obtener la última evaluación si existe
                const currentSuspendData = getSCORMData('cmi.suspend_data');
                if (currentSuspendData) {
                    try {
                        const existingData = JSON.parse(currentSuspendData);
                        if (existingData.lastEvaluation) {
                            completionData.lastEvaluation = existingData.lastEvaluation;
                        }
                    } catch (e) {
                        console.error("Error al obtener evaluación previa:", e);
                    }
                }
                
                // GUARDAR ESTADO FINAL EN SCORM
                setSCORMData('cmi.core.score.raw', currentScore.toString());
                setSCORMData('cmi.core.score.max', '40');
                setSCORMData('cmi.core.score.min', '0');
                setSCORMData('cmi.core.lesson_status', 'completed');
                setSCORMData('cmi.core.exit', 'normal');
                setSCORMData('cmi.core.lesson_location', `COMPLETED_${currentScore}_40_${isPassed ? 'PASSED' : 'FAILED'}`);
                setSCORMData('cmi.core.session_time', calculateSessionTime());
                setSCORMData('cmi.suspend_data', JSON.stringify(completionData));
                
                // COMMITS CRÍTICOS PARA PERSISTENCIA
                const commit1 = commitSCORMData();
                console.log(`Commit 1: ${commit1}`);
                
                setTimeout(() => {
                    const commit2 = commitSCORMData();
                    console.log(`Commit 2: ${commit2}`);
                }, 1000);
                
                setTimeout(() => {
                    setSCORMData('cmi.core.lesson_status', 'completed');
                    const commit3 = commitSCORMData();
                    console.log(`Commit 3 FINAL: ${commit3}`);
                }, 3000);
                
                // Track completion en Analytics
                trackActivityCompletion(currentScore, totalAttempts);
                
                // Mostrar pantalla de finalización inmediatamente
                showCompletionScreen(completionData);
                
                console.log("=== ACTIVIDAD FINALIZADA Y BLOQUEADA ===");
                
            } catch (error) {
                console.error("❌ Error al finalizar actividad:", error);
                alert("Error al finalizar la actividad. Por favor, contacte al administrador.");
            }
        }
        
        // Resto de funciones (mantienen la funcionalidad original)
        function populateScenarios() {
            for (const key in scenarios) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = scenarios[key].name;
                scenarioSelector.appendChild(option);
            }
            updateDescription();
        }

        function updateDescription() {
            const selectedKey = scenarioSelector.value;
            const scenario = scenarios[selectedKey];
            scenarioDescription.textContent = scenario.goal;
            
            // Track scenario selection
            trackScenarioSelection(selectedKey, scenario.name);
        }

        async function handleAnalysis() {
            const studentPromptText = studentPromptEl.value.trim();
            if (!studentPromptText) {
                alert('Por favor, escriba un prompt antes de solicitar el análisis.');
                return;
            }
            
            // Verificar límite de intentos
            if (totalAttempts >= SCORM_CONFIG.maxAttempts) {
                alert(getLocalizedText('maxAttemptsReached'));
                return;
            }
            
            // Verificar configuración de API
            if (!OPENAI_CONFIG.apiKey || OPENAI_CONFIG.apiKey === "INSERTE_AQUI_SU_CLAVE_DE_OPENAI") {
                alert("Por favor, configure su clave de API de OpenAI en js/config.js para continuar.");
                return;
            }

            setLoading(true);
            totalAttempts++;
            
            // Actualizar información de intentos en la interfaz
            updateAttemptsDisplay();
            
            // Guardar número de intentos en SCORM
            if (scormInitialized) {
                setSCORMData('cmi.core.lesson_location', `attempt_${totalAttempts}`);
            }
            
            const scenario = scenarios[scenarioSelector.value];
            
            const metaPrompt = `Eres un evaluador académico estricto y preciso especializado en prompts para IA. Tu tarea es evaluar el prompt del estudiante de manera objetiva y rigurosa según criterios específicos.

**ESCENARIO A EVALUAR:**
${scenario.goal}

**TÉCNICA ESPERADA:** ${scenario.technique}

**CRITERIOS DE EVALUACIÓN (CADA UNO VALE EXACTAMENTE 10 PUNTOS):**
${scenario.rubric.map((item, index) => `${index + 1}. ${item.criterion} (10 puntos)`).join('\n')}

**PROMPT DEL ESTUDIANTE:**
"${studentPromptText}"

**INSTRUCCIONES DE EVALUACIÓN:**

Para CADA criterio, debes decidir ÚNICAMENTE entre dos opciones:
- ✅ CUMPLE = 10 puntos (el criterio se cumple claramente y de manera explícita)
- ❌ NO CUMPLE = 0 puntos (el criterio no se cumple, está ausente, o es vago/implícito)

**REGLAS ESTRICTAS:**
1. NO hay puntos parciales - cada criterio vale exactamente 10 puntos o 0 puntos
2. Un criterio solo se cumple si está EXPLÍCITAMENTE presente en el prompt
3. Si un elemento está implícito pero no se menciona claramente, NO CUMPLE
4. Si faltan detalles específicos que el criterio requiere, NO CUMPLE
5. Sé exigente: el estudiante debe demostrar dominio claro de cada criterio

**EVALUACIÓN PASO A PASO:**
Analiza el prompt del estudiante palabra por palabra y evalúa:

Criterio 1 - "${scenario.rubric[0].criterion}":
- ¿Está presente explícitamente? ¿Es específico y claro?
- Resultado: [CUMPLE = 10 puntos] o [NO CUMPLE = 0 puntos]

Criterio 2 - "${scenario.rubric[1].criterion}":
- ¿Está presente explícitamente? ¿Es específico y claro?
- Resultado: [CUMPLE = 10 puntos] o [NO CUMPLE = 0 puntos]

Criterio 3 - "${scenario.rubric[2].criterion}":
- ¿Está presente explícitamente? ¿Es específico y claro?
- Resultado: [CUMPLE = 10 puntos] o [NO CUMPLE = 0 puntos]

Criterio 4 - "${scenario.rubric[3].criterion}":
- ¿Está presente explícitamente? ¿Es específico y claro?
- Resultado: [CUMPLE = 10 puntos] o [NO CUMPLE = 0 puntos]

**PUNTAJE TOTAL:** Suma exacta de puntos obtenidos (máximo 40 puntos)

**FORMATO DE RESPUESTA OBLIGATORIO:**
Responde ÚNICAMENTE con un objeto JSON válido:

{
  "score": [número exacto de puntos obtenidos 0-40],
  "feedback": [
    {
      "criterion": "${scenario.rubric[0].criterion}",
      "fulfilled": [true/false],
      "justification": "[Explicación específica de por qué cumple o no cumple, citando partes del prompt]"
    },
    {
      "criterion": "${scenario.rubric[1].criterion}",
      "fulfilled": [true/false],
      "justification": "[Explicación específica de por qué cumple o no cumple, citando partes del prompt]"
    },
    {
      "criterion": "${scenario.rubric[2].criterion}",
      "fulfilled": [true/false],
      "justification": "[Explicación específica de por qué cumple o no cumple, citando partes del prompt]"
    },
    {
      "criterion": "${scenario.rubric[3].criterion}",
      "fulfilled": [true/false],
      "justification": "[Explicación específica de por qué cumple o no cumple, citando partes del prompt]"
    }
  ],
  "ideal_structure": {
    "Contexto": "[Cómo debería establecerse el contexto para este escenario]",
    "Tarea_específica": "[Cómo debería definirse la tarea de manera clara]",
    "Restricciones": "[Qué limitaciones o parámetros debería incluir]",
    "Formato_de_salida": "[Cómo debería especificarse el formato deseado]"
  }
}

RECUERDA: Sé estricto y objetivo. Solo asigna puntos cuando el criterio se cumple de manera clara y explícita.`;

            try {
                const aiFeedback = await getAIFeedback(metaPrompt);
                
                // Validar consistencia de la evaluación
                const validatedFeedback = validateAndCorrectEvaluation(aiFeedback);
                renderFeedback(validatedFeedback);
                
                // Registrar en SCORM
                const scenario = scenarios[scenarioSelector.value];
                const maxScore = scenario.rubric.reduce((acc, item) => acc + item.score, 0);
                registerScoreInLMS(validatedFeedback.score, maxScore);
                
                // Track prompt submission in Analytics
                trackPromptSubmission(scenarioSelector.value, validatedFeedback.score, totalAttempts);
                
            } catch (error) {
                console.error("Error al obtener feedback de la IA:", error);
                const errorFeedback = {
                    score: 0,
                    feedback: [{ criterion: "Error de conexión", fulfilled: false, justification: "No se pudo contactar al evaluador de IA. Verifique su clave de API o intente más tarde." }],
                    ideal_structure: { "Error": "No se pudo generar la estructura." }
                };
                renderFeedback(errorFeedback);
            } finally {
                setLoading(false);
            }
        }

        async function getAIFeedback(prompt) {
            const apiUrl = 'https://api.openai.com/v1/chat/completions';
            const payload = {
                model: "gpt-4o-mini",
                messages: [{ role: "user", content: prompt }],
                response_format: { type: "json_object" }
            };
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${OPENAI_CONFIG.apiKey}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Error de la API de OpenAI: ${errorData.error.message}`);
            }
            
            const result = await response.json();
            if (result.choices && result.choices[0] && result.choices[0].message && result.choices[0].message.content) {
                return JSON.parse(result.choices[0].message.content);
            }
            throw new Error("Respuesta de API inválida.");
        }
        
        // Funciones para indicadores de estado
        function updateAIStatus(status) {
            const aiIndicator = widget.querySelector('#aiStatus .pcw-status-dot');
            const aiIcon = widget.querySelector('#aiStatus .pcw-status-icon');
            
            if (!aiIndicator || !aiIcon) return;
            
            // Remover clases anteriores
            aiIndicator.classList.remove('pcw-status-connected', 'pcw-status-disconnected', 'pcw-status-connecting');
            
            switch(status) {
                case 'connected':
                    aiIndicator.classList.add('pcw-status-connected');
                    aiIcon.style.color = '#22c55e';
                    aiConnected = true;
                    console.log("🤖 IA: Conectada");
                    break;
                case 'connecting':
                    aiIndicator.classList.add('pcw-status-connecting');
                    aiIcon.style.color = '#f59e0b';
                    console.log("🤖 IA: Conectando...");
                    break;
                case 'disconnected':
                default:
                    aiIndicator.classList.add('pcw-status-disconnected');
                    aiIcon.style.color = '#ef4444';
                    aiConnected = false;
                    console.log("🤖 IA: Desconectada");
                    break;
            }
        }

        function updateScormStatus(status) {
            const scormIndicator = widget.querySelector('#scormStatus .pcw-status-dot');
            const scormIcon = widget.querySelector('#scormStatus .pcw-status-icon');
            
            if (!scormIndicator || !scormIcon) return;
            
            // Remover clases anteriores
            scormIndicator.classList.remove('pcw-status-connected', 'pcw-status-disconnected', 'pcw-status-connecting');
            
            switch(status) {
                case 'connected':
                    scormIndicator.classList.add('pcw-status-connected');
                    scormIcon.style.color = '#22c55e';
                    scormConnected = true;
                    console.log("🎓 LMS: Conectado");
                    break;
                case 'connecting':
                    scormIndicator.classList.add('pcw-status-connecting');
                    scormIcon.style.color = '#f59e0b';
                    console.log("🎓 LMS: Conectando...");
                    break;
                case 'disconnected':
                default:
                    scormIndicator.classList.add('pcw-status-disconnected');
                    scormIcon.style.color = '#ef4444';
                    scormConnected = false;
                    console.log("🎓 LMS: Desconectado");
                    break;
            }
        }

        function validateAndCorrectEvaluation(evaluation) {
            // Validar que la evaluación tenga la estructura correcta
            if (!evaluation || !evaluation.feedback || !Array.isArray(evaluation.feedback)) {
                console.error("❌ Estructura de evaluación inválida");
                return {
                    score: 0,
                    feedback: [
                        { criterion: "Error de evaluación", fulfilled: false, justification: "La evaluación no pudo completarse correctamente." }
                    ],
                    ideal_structure: { "Error": "No se pudo generar la estructura ideal" }
                };
            }
            
            // CRÍTICO: Calcular puntaje real basado en criterios cumplidos
            let calculatedScore = 0;
            const correctedFeedback = evaluation.feedback.map((item, index) => {
                // Asegurar que fulfilled sea booleano estricto
                const fulfilled = item.fulfilled === true || item.fulfilled === 'true' || item.fulfilled === 1;
                if (fulfilled) {
                    calculatedScore += 10; // Cada criterio vale exactamente 10 puntos
                }
                
                console.log(`✓ Criterio ${index + 1}: ${fulfilled ? '10 puntos' : '0 puntos'} - ${item.criterion}`);
                
                return {
                    criterion: item.criterion || `Criterio ${index + 1}`,
                    fulfilled: fulfilled,
                    justification: item.justification || "Sin justificación proporcionada"
                };
            });
            
            // Verificar consistencia con puntaje reportado por IA
            const reportedScore = parseInt(evaluation.score) || 0;
            if (calculatedScore !== reportedScore) {
                console.warn(`🔧 CORRECCIÓN CRÍTICA: IA reportó ${reportedScore} puntos, cálculo real ${calculatedScore} puntos`);
                console.warn(`📊 Desglose: ${correctedFeedback.map((item, i) => `C${i+1}:${item.fulfilled ? 10 : 0}`).join(' + ')} = ${calculatedScore}`);
            }
            
            // Validar que tengamos exactamente 4 criterios
            if (correctedFeedback.length !== 4) {
                console.error(`⚠️ Error: Se esperaban 4 criterios, pero se recibieron ${correctedFeedback.length}`);
                
                // Rellenar criterios faltantes
                while (correctedFeedback.length < 4) {
                    correctedFeedback.push({
                        criterion: `Criterio ${correctedFeedback.length + 1} (no evaluado)`,
                        fulfilled: false,
                        justification: "Este criterio no pudo ser evaluado correctamente."
                    });
                }
            }
            
            console.log(`✅ Validación completada: ${calculatedScore}/40 puntos (${Math.round((calculatedScore/40)*100)}%)`);
            console.log(`📋 Criterios cumplidos: ${correctedFeedback.filter(item => item.fulfilled).length}/4`);
            
            return {
                score: calculatedScore, // USAR SIEMPRE EL PUNTAJE CALCULADO, NO EL REPORTADO
                feedback: correctedFeedback,
                ideal_structure: evaluation.ideal_structure || { "Error": "Estructura ideal no disponible" }
            };
        }

        function calculateGrade(score, maxScore) {
            if (maxScore === 0) return 1.0;
            
            const percentage = (score / maxScore) * 100;
            
            // Sistema de calificación estándar para compatibilidad universal con LMS
            // Cada LMS aplicará su propia escala según su configuración
            // Esta es solo una referencia visual para el estudiante
            let grade;
            
            if (percentage < 60) {
                // Escala reprobatoria: 0% a 60% → 1.0 a 4.0
                grade = 1.0 + (3.0 * percentage / 60);
            } else {
                // Escala aprobatoria: 60% a 100% → 4.0 a 7.0
                grade = 4.0 + (3.0 * (percentage - 60) / 40);
            }
            
            // Asegurar rango válido
            grade = Math.max(1.0, Math.min(7.0, grade));
            
            // Redondear a 1 decimal para compatibilidad estándar
            return Math.round(grade * 10) / 10;
        }

        function renderFeedback(evaluation) {
            const scenario = scenarios[scenarioSelector.value];
            const totalPossibleScore = scenario.rubric.reduce((acc, item) => acc + item.score, 0);
            const grade = calculateGrade(evaluation.score, totalPossibleScore);
            
            // Validar que el puntaje sea correcto
            let actualScore = 0;
            evaluation.feedback.forEach(item => {
                if (item.fulfilled) actualScore += 10;
            });
            
            // Usar el puntaje calculado si hay discrepancia
            if (actualScore !== evaluation.score) {
                console.warn(`Discrepancia de puntaje detectada: IA reportó ${evaluation.score}, cálculo real ${actualScore}`);
                evaluation.score = actualScore;
            }

            const feedbackHtml = evaluation.feedback.map((item, index) => {
                const type = item.fulfilled ? 'acierto' : 'mejora';
                const points = item.fulfilled ? 10 : 0;
                const icon = type === 'acierto' 
                    ? `<svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>`
                    : `<svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>`;
                
                return `<li class="pcw-feedback-item ${type}">
                    ${icon}
                    <div class="pcw-feedback-text">
                        <strong>${item.criterion} - ${points}/10 puntos</strong>
                        <span>${item.justification}</span>
                    </div>
                </li>`;
            }).join('');
            
            const structureButton = document.createElement('button');
            structureButton.id = 'showStructureButton';
            structureButton.className = 'pcw-button pcw-button-secondary';
            structureButton.innerHTML = `<svg class="pcw-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path></svg>Ver anatomía del prompt ideal`;
            
            structureButton.addEventListener('click', () => {
                displayIdealStructure(evaluation.ideal_structure);
            });

            // Mostrar desglose detallado de puntuación
            const scoreBreakdown = evaluation.feedback.map((item, index) => 
                `Criterio ${index + 1}: ${item.fulfilled ? 10 : 0}/10`
            ).join(' + ') + ` = ${evaluation.score}/40`;

            const percentage = Math.round((evaluation.score / totalPossibleScore) * 100);
            const isPassed = percentage >= 60;

            feedbackContainer.innerHTML = `
                <div class="pcw-score-display">
                    <div>Puntaje Total: <span class="score">${evaluation.score}/${totalPossibleScore}</span></div>
                    <div style="font-size: 0.9rem; margin-top: 5px; color: var(--light-text-color);">
                        ${scoreBreakdown}
                    </div>
                    <div>Nota: <span class="score">${grade}</span></div>
                    <div style="font-size: 0.8rem; margin-top: 5px; color: var(--light-text-color);">
                        Porcentaje: ${percentage}% (${isPassed ? 'APROBADO' : 'REPROBADO'})
                    </div>
                </div>
                <ul class="pcw-feedback-list">${feedbackHtml}</ul>
            `;
            feedbackContainer.appendChild(structureButton);
            
            // CRÍTICO: Guardar evaluación completa en suspend_data inmediatamente
            if (scormInitialized) {
                try {
                    const currentSuspendDataStr = getSCORMData('cmi.suspend_data');
                    let suspendData = {};
                    
                    if (currentSuspendDataStr) {
                        suspendData = JSON.parse(currentSuspendDataStr);
                    }
                    
                    // Actualizar con la evaluación completa
                    suspendData.lastEvaluation = {
                        score: evaluation.score,
                        feedback: evaluation.feedback,
                        ideal_structure: evaluation.ideal_structure,
                        scenarioKey: scenarioSelector.value,
                        scenarioName: scenario.name,
                        timestamp: new Date().toISOString(),
                        grade: grade,
                        percentage: percentage,
                        promptText: studentPromptEl.value.trim(),
                        isPassed: isPassed
                    };
                    
                    // Actualizar otros campos críticos
                    suspendData.rawScore = evaluation.score;
                    suspendData.attempts = totalAttempts;
                    suspendData.scenarioKey = scenarioSelector.value;
                    suspendData.percentage = percentage;
                    suspendData.grade = grade;
                    suspendData.isPassed = isPassed;
                    
                    // Guardar inmediatamente en SCORM
                    setSCORMData('cmi.suspend_data', JSON.stringify(suspendData));
                    setSCORMData('cmi.core.score.raw', evaluation.score.toString());
                    setSCORMData('cmi.core.score.max', '40');
                    setSCORMData('cmi.core.lesson_location', `attempt_${totalAttempts}_score_${evaluation.score}_${isPassed ? 'PASSED' : 'FAILED'}`);
                    
                    // Commit inmediato
                    const commit1 = commitSCORMData();
                    console.log(`💾 Evaluación guardada en SCORM: ${commit1}`);
                    
                    // Commit diferido para asegurar
                    setTimeout(() => {
                        const commit2 = commitSCORMData();
                        console.log(`💾 Commit diferido: ${commit2}`);
                    }, 1000);
                    
                    // Mostrar botón de finalizar si aprobó
                    if (isPassed) {
                        completeActivityButton.style.display = 'block';
                        console.log("✅ Estudiante aprobó - mostrando botón de finalizar");
                    }
                    
                } catch (error) {
                    console.error("❌ Error crítico al guardar evaluación:", error);
                }
            }
            
            // Log detallado para debugging
            console.log("=== EVALUACIÓN REGISTRADA ===");
            console.log("Escenario:", scenario.name);
            console.log("Puntaje obtenido:", evaluation.score, "de", totalPossibleScore);
            console.log("Porcentaje:", percentage + "%");
            console.log("Estado:", isPassed ? 'APROBADO' : 'REPROBADO');
            console.log("Nota:", grade);
            console.log("Guardado en SCORM:", scormInitialized ? 'SÍ' : 'NO');
            console.log("==============================");
        }
        
        function displayIdealStructure(structure) {
            rubricModalTitle.textContent = `Anatomía de un prompt ideal`;
            const structureHtml = Object.entries(structure).map(([key, value]) => `
                <div class="pcw-structure-item">
                    <strong>${key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</strong> ${value}
                </div>
            `).join('');
            
            rubricModalBody.innerHTML = `<div class="pcw-structure-display">${structureHtml}</div>`;
            rubricModal.style.display = 'block';
        }

        function setLoading(isLoading) {
            if (isLoading) {
                feedbackContainer.innerHTML = `<div class="loader"><div class="spinner"></div><p>Analizando su propuesta...</p></div>`;
            }
            analyzeButton.disabled = isLoading;
        }
        
        function displayRubric() {
            const scenario = scenarios[scenarioSelector.value];
            rubricModalTitle.textContent = `Pauta de evaluación`;
            
            const tableHtml = `
                <table class="pcw-rubric-table">
                    <thead>
                        <tr>
                            <th>Criterio para: ${scenario.name}</th>
                            <th>Puntaje</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${scenario.rubric.map(item => `
                            <tr>
                                <td>${item.criterion}</td>
                                <td>${item.score}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
            rubricModalBody.innerHTML = tableHtml;
            rubricModal.style.display = 'block';
        }

        // Event Listeners
        scenarioSelector.addEventListener('change', updateDescription);
        analyzeButton.addEventListener('click', handleAnalysis);
        showRubricButton.addEventListener('click', displayRubric);
        completeActivityButton.addEventListener('click', completeActivity);
        
        // Event listeners para modales
        closeModalButton.addEventListener('click', () => {
            rubricModal.style.display = 'none';
        });
        
        scormModalClose.addEventListener('click', () => {
            scormModal.style.display = 'none';
        });
        
        window.addEventListener('click', (event) => {
            if (event.target == rubricModal) {
                rubricModal.style.display = 'none';
            }
            if (event.target == scormModal) {
                scormModal.style.display = 'none';
            }
        });

        // Manejar cierre de ventana para SCORM
        window.addEventListener('beforeunload', function(e) {
            if (scormInitialized) {
                console.log("💾 Guardando datos antes del cierre...");
                
                // Actualizar tiempo de sesión
                setSCORMData('cmi.core.session_time', calculateSessionTime());
                
                // Commit crítico de todos los datos
                const finalCommit = commitSCORMData();
                console.log("📤 Commit final resultado:", finalCommit);
                
                // Establecer exit normal (no cerrar sesión para mantener persistencia)
                setSCORMData('cmi.core.exit', 'normal');
                
                // Commit final
                commitSCORMData();
                
                console.log("✅ Datos guardados exitosamente antes del cierre");
            }
        });

        // Auto-guardado más agresivo para máxima persistencia
        if (scormInitialized && SCORM_CONFIG.autoCommit) {
            // Guardado cada 15 segundos (más frecuente)
            setInterval(() => {
                if (scormInitialized) {
                    const result = commitSCORMData();
                    console.log("🔄 Auto-commit ejecutado:", result);
                }
            }, 15000); // 15 segundos en lugar de 30
            
            // Guardado adicional cada vez que el usuario interactúa
            ['click', 'keypress', 'change'].forEach(eventType => {
                document.addEventListener(eventType, () => {
                    if (scormInitialized && currentScore > 0) {
                        // Debounce para evitar commits excesivos
                        clearTimeout(window.interactionCommitTimeout);
                        window.interactionCommitTimeout = setTimeout(() => {
                            commitSCORMData();
                            console.log("💡 Commit por interacción del usuario");
                        }, 2000);
                    }
                });
            });
        }

        // Inicializar la aplicación
        populateScenarios();
        updateAttemptsDisplay(); // Mostrar estado inicial de intentos
        
        // Track session start
        trackSessionStart();
    });
    </script>
</body>
</html>
